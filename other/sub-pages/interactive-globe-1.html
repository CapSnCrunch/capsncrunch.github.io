<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe Controls Comparison</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .container {
            display: flex;
            gap: 60px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .globe-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        canvas {
            cursor: grab;
            border-radius: 50%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }
        canvas:active {
            cursor: grabbing;
        }
        .label {
            text-align: center;
            max-width: 300px;
        }
        .label h3 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
        }
        .label p {
            margin: 0;
            color: #666;
            font-size: 14px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="globe-wrapper">
            <canvas id="globe1"></canvas>
            <div class="label">
                <h3>Trackball</h3>
                <p>Grab any point and it follows your cursor</p>
            </div>
        </div>
        
        <div class="globe-wrapper">
            <canvas id="globe2"></canvas>
            <div class="label">
                <h3>Axis Lock</h3>
                <p>Drag horizontally or vertically to rotate on one axis</p>
            </div>
        </div>
    </div>
    
    <script>
        // Shared globe settings
        const size = Math.min(window.innerWidth * 0.35, window.innerHeight * 0.5, 350);
        const centerX = size / 2;
        const centerY = size / 2;
        const radius = size * 0.4;
        
        // Shared marker data
        const markers = [
            { lat: 0, lon: 0, color: '#ff4444' },
            { lat: Math.PI/4, lon: Math.PI/4, color: '#44ff44' },
            { lat: -Math.PI/4, lon: Math.PI/2, color: '#4444ff' },
            { lat: Math.PI/3, lon: -Math.PI/3, color: '#ff44ff' },
            { lat: -Math.PI/6, lon: Math.PI, color: '#ffaa44' },
            { lat: Math.PI/6, lon: -Math.PI/2, color: '#44ffff' },
        ];
        
        // Shared utility functions
        function sphericalTo3D(lat, lon) {
            const x = radius * Math.cos(lat) * Math.cos(lon);
            const y = radius * Math.sin(lat);
            const z = radius * Math.cos(lat) * Math.sin(lon);
            return { x, y, z };
        }
        
        function applyMatrix(point, matrix) {
            return {
                x: matrix[0][0] * point.x + matrix[0][1] * point.y + matrix[0][2] * point.z,
                y: matrix[1][0] * point.x + matrix[1][1] * point.y + matrix[1][2] * point.z,
                z: matrix[2][0] * point.x + matrix[2][1] * point.y + matrix[2][2] * point.z
            };
        }
        
        function multiplyMatrices(a, b) {
            const result = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            return result;
        }
        
        function rotationMatrixFromAxisAngle(axis, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const t = 1 - c;
            const x = axis.x, y = axis.y, z = axis.z;
            
            return [
                [t*x*x + c,   t*x*y - s*z, t*x*z + s*y],
                [t*x*y + s*z, t*y*y + c,   t*y*z - s*x],
                [t*x*z - s*y, t*y*z + s*x, t*z*z + c  ]
            ];
        }
        
        function cross(a, b) {
            return {
                x: a.y * b.z - a.z * b.y,
                y: a.z * b.x - a.x * b.z,
                z: a.x * b.y - a.y * b.x
            };
        }
        
        function normalize(v) {
            const length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            if (length < 0.0001) return { x: 0, y: 0, z: 1 };
            return { x: v.x / length, y: v.y / length, z: v.z / length };
        }
        
        function project(point3D) {
            return {
                x: centerX + point3D.x,
                y: centerY - point3D.y,
                visible: point3D.z >= 0
            };
        }
        
        // Drawing function used by both globes
        function drawGlobe(ctx, rotationMatrix) {
            ctx.clearRect(0, 0, size, size);
            
            // Draw globe outline
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw latitude and longitude lines
            ctx.strokeStyle = '#e8e8e8';
            ctx.lineWidth = 1;
            
            // Latitude lines
            for (let lat = -Math.PI/3; lat <= Math.PI/3; lat += Math.PI/6) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lon = -Math.PI; lon <= Math.PI; lon += Math.PI/36) {
                    let point = sphericalTo3D(lat, lon);
                    point = applyMatrix(point, rotationMatrix);
                    const projected = project(point);
                    
                    if (projected.visible) {
                        if (firstPoint) {
                            ctx.moveTo(projected.x, projected.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(projected.x, projected.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }
            
            // Longitude lines
            for (let lon = 0; lon < Math.PI * 2; lon += Math.PI/4) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lat = -Math.PI/2; lat <= Math.PI/2; lat += Math.PI/36) {
                    let point = sphericalTo3D(lat, lon);
                    point = applyMatrix(point, rotationMatrix);
                    const projected = project(point);
                    
                    if (projected.visible) {
                        if (firstPoint) {
                            ctx.moveTo(projected.x, projected.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(projected.x, projected.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }
            
            // Draw markers
            markers.forEach(marker => {
                let point = sphericalTo3D(marker.lat, marker.lon);
                point = applyMatrix(point, rotationMatrix);
                const projected = project(point);
                
                if (projected.visible) {
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = marker.color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }
        
        // GLOBE 1: Trackball control
        (function() {
            const canvas = document.getElementById('globe1');
            const ctx = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;
            
            let rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            let isDragging = false;
            let lastSpherePoint = null;
            
            function screenToSphere(screenX, screenY) {
                const rect = canvas.getBoundingClientRect();
                const x = (screenX - rect.left - centerX) / radius;
                const y = (centerY - (screenY - rect.top)) / radius;
                const lengthSquared = x * x + y * y;
                
                if (lengthSquared > 1.0) {
                    const length = Math.sqrt(lengthSquared);
                    return { x: x / length, y: y / length, z: 0 };
                } else {
                    return { x, y, z: Math.sqrt(1 - lengthSquared) };
                }
            }
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastSpherePoint = screenToSphere(e.clientX, e.clientY);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && lastSpherePoint) {
                    const currentSpherePoint = screenToSphere(e.clientX, e.clientY);
                    const axis = cross(lastSpherePoint, currentSpherePoint);
                    const axisLength = Math.sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
                    
                    if (axisLength > 0.0001) {
                        const normalizedAxis = normalize(axis);
                        const angle = Math.asin(Math.min(1, axisLength));
                        const incrementalRotation = rotationMatrixFromAxisAngle(normalizedAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        lastSpherePoint = currentSpherePoint;
                        drawGlobe(ctx, rotationMatrix);
                    }
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                lastSpherePoint = null;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                lastSpherePoint = null;
            });
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                lastSpherePoint = screenToSphere(e.touches[0].clientX, e.touches[0].clientY);
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && lastSpherePoint) {
                    const currentSpherePoint = screenToSphere(e.touches[0].clientX, e.touches[0].clientY);
                    const axis = cross(lastSpherePoint, currentSpherePoint);
                    const axisLength = Math.sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
                    
                    if (axisLength > 0.0001) {
                        const normalizedAxis = normalize(axis);
                        const angle = Math.asin(Math.min(1, axisLength));
                        const incrementalRotation = rotationMatrixFromAxisAngle(normalizedAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        lastSpherePoint = currentSpherePoint;
                        drawGlobe(ctx, rotationMatrix);
                    }
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
                lastSpherePoint = null;
            });
            
            drawGlobe(ctx, rotationMatrix);
        })();
        
        // GLOBE 2: Axis Lock control
        (function() {
            const canvas = document.getElementById('globe2');
            const ctx = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;
            
            let rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;
            let dragAxis = null; // 'horizontal' or 'vertical'
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                dragAxis = null;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    
                    // Determine drag direction on first significant movement
                    if (!dragAxis) {
                        if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                            dragAxis = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                        }
                    }
                    
                    if (dragAxis === 'horizontal') {
                        // Rotate around Y axis (vertical axis)
                        const angle = deltaX * 0.01;
                        const yAxis = { x: 0, y: 1, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(yAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    } else if (dragAxis === 'vertical') {
                        // Rotate around X axis (horizontal axis)
                        const angle = deltaY * 0.01;
                        const xAxis = { x: 1, y: 0, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(xAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    }
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                    drawGlobe(ctx, rotationMatrix);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragAxis = null;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                dragAxis = null;
            });
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                dragAxis = null;
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;
                    
                    if (!dragAxis) {
                        if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                            dragAxis = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                        }
                    }
                    
                    if (dragAxis === 'horizontal') {
                        const angle = -deltaX * 0.01;
                        const yAxis = { x: 0, y: 1, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(yAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    } else if (dragAxis === 'vertical') {
                        const angle = -deltaY * 0.01;
                        const xAxis = { x: 1, y: 0, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(xAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    }
                    
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    drawGlobe(ctx, rotationMatrix);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
                dragAxis = null;
            });
            
            drawGlobe(ctx, rotationMatrix);
        })();
    </script>
</body>
</html>