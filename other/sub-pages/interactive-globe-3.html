<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe Controls Comparison</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .container {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .globe-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        canvas {
            cursor: grab;
            border-radius: 50%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }
        canvas:active {
            cursor: grabbing;
        }
        .label {
            text-align: center;
            max-width: 300px;
        }
        .label h3 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
        }
        .label p {
            margin: 0;
            color: #666;
            font-size: 14px;
            line-height: 1.4;
        }
        .reset-button {
            background: white;
            border: 2px solid #d0d0d0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-top: calc(50% - 60px);
        }
        .reset-button:hover {
            background: #f8f8f8;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }
        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .reset-button svg {
            width: 24px;
            height: 24px;
            stroke: #666;
            stroke-width: 2;
            fill: none;
            transition: transform 0.3s ease;
        }
        .reset-button:hover svg {
            transform: rotate(-45deg);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="globe-wrapper">
            <canvas id="globe1"></canvas>
            <div class="label">
                <h3>Trackball</h3>
                <p>Grab any point and it follows your cursor</p>
            </div>
        </div>
        
        <button class="reset-button" id="resetButton" title="Reset globes">
            <svg viewBox="0 0 24 24">
                <path d="M12 4a8 8 0 1 1-3.5 15.2" />
                <polyline points="12 4 12 8 8 8" />
            </svg>
        </button>
        
        <div class="globe-wrapper">
            <canvas id="globe2"></canvas>
            <div class="label">
                <h3>Axis Lock</h3>
                <p>Drag horizontally or vertically to rotate on one axis</p>
            </div>
        </div>
    </div>
    
    <script>
        // Shared globe settings
        const size = Math.min(window.innerWidth * 0.45, window.innerHeight * 0.65, 500);
        const centerX = size / 2;
        const centerY = size / 2;
        const radius = size * 0.42;
        
        // Shared marker data with animation parameters
        const markers = [
            { lat: 0, lon: 0, color: '#ff4444', speed: 0.01, path: 'lon', trail: [] },
            { lat: Math.PI/4, lon: Math.PI/4, color: '#44ff44', speed: 0.012, path: 'lat', trail: [] },
            { lat: -Math.PI/4, lon: Math.PI/2, color: '#4444ff', speed: 0.008, path: 'lon', trail: [] },
            { lat: Math.PI/3, lon: -Math.PI/3, color: '#ff44ff', speed: 0.015, path: 'lat', trail: [] },
            { lat: -Math.PI/6, lon: Math.PI, color: '#ffaa44', speed: 0.011, path: 'lon', trail: [] },
            { lat: Math.PI/6, lon: -Math.PI/2, color: '#44ffff', speed: 0.009, path: 'lat', trail: [] },
        ];
        
        const maxTrailLength = 50;
        let animationTime = 0;
        
        // Shared utility functions
        function sphericalTo3D(lat, lon) {
            const x = radius * Math.cos(lat) * Math.cos(lon);
            const y = radius * Math.sin(lat);
            const z = radius * Math.cos(lat) * Math.sin(lon);
            return { x, y, z };
        }
        
        function applyMatrix(point, matrix) {
            return {
                x: matrix[0][0] * point.x + matrix[0][1] * point.y + matrix[0][2] * point.z,
                y: matrix[1][0] * point.x + matrix[1][1] * point.y + matrix[1][2] * point.z,
                z: matrix[2][0] * point.x + matrix[2][1] * point.y + matrix[2][2] * point.z
            };
        }
        
        function multiplyMatrices(a, b) {
            const result = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            return result;
        }
        
        function rotationMatrixFromAxisAngle(axis, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const t = 1 - c;
            const x = axis.x, y = axis.y, z = axis.z;
            
            return [
                [t*x*x + c,   t*x*y - s*z, t*x*z + s*y],
                [t*x*y + s*z, t*y*y + c,   t*y*z - s*x],
                [t*x*z - s*y, t*y*z + s*x, t*z*z + c  ]
            ];
        }
        
        function cross(a, b) {
            return {
                x: a.y * b.z - a.z * b.y,
                y: a.z * b.x - a.x * b.z,
                z: a.x * b.y - a.y * b.x
            };
        }
        
        function normalize(v) {
            const length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            if (length < 0.0001) return { x: 0, y: 0, z: 1 };
            return { x: v.x / length, y: v.y / length, z: v.z / length };
        }
        
        function project(point3D) {
            return {
                x: centerX + point3D.x,
                y: centerY - point3D.y,
                z: point3D.z
            };
        }
        
        // Convert hex color to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Update marker positions
        function updateMarkers() {
            animationTime += 0.016; // Approximate frame time
            
            markers.forEach(marker => {
                if (marker.path === 'lon') {
                    // Move along longitude (constant latitude)
                    marker.lon += marker.speed;
                    if (marker.lon > Math.PI) marker.lon -= 2 * Math.PI;
                    if (marker.lon < -Math.PI) marker.lon += 2 * Math.PI;
                } else {
                    // Move along latitude (constant longitude)
                    marker.lat += marker.speed;
                    // Bounce at poles
                    if (marker.lat > Math.PI/2.2) {
                        marker.lat = Math.PI/2.2;
                        marker.speed = -marker.speed;
                    }
                    if (marker.lat < -Math.PI/2.2) {
                        marker.lat = -Math.PI/2.2;
                        marker.speed = -marker.speed;
                    }
                }
                
                // Add current position to trail
                marker.trail.push({ lat: marker.lat, lon: marker.lon });
                
                // Limit trail length
                if (marker.trail.length > maxTrailLength) {
                    marker.trail.shift();
                }
            });
        }
        
        // Drawing function used by both globes
        function drawGlobe(ctx, rotationMatrix) {
            updateMarkers();
            ctx.clearRect(0, 0, size, size);
            
            // Draw globe outline
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw latitude and longitude lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Latitude lines
            for (let lat = -Math.PI/3; lat <= Math.PI/3; lat += Math.PI/12) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lon = -Math.PI; lon <= Math.PI; lon += Math.PI/36) {
                    let point = sphericalTo3D(lat, lon);
                    point = applyMatrix(point, rotationMatrix);
                    const projected = project(point);
                    
                    if (projected.z >= 0) {
                        if (firstPoint) {
                            ctx.moveTo(projected.x, projected.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(projected.x, projected.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }
            
            // Longitude lines
            for (let lon = 0; lon < Math.PI * 2; lon += Math.PI/8) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lat = -Math.PI/2; lat <= Math.PI/2; lat += Math.PI/36) {
                    let point = sphericalTo3D(lat, lon);
                    point = applyMatrix(point, rotationMatrix);
                    const projected = project(point);
                    
                    if (projected.z >= 0) {
                        if (firstPoint) {
                            ctx.moveTo(projected.x, projected.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(projected.x, projected.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }
            
            // Draw trails for each marker as solid hovering worms
            markers.forEach(marker => {
                if (marker.trail.length < 2) return;
                
                // Build segments with visibility checks
                const visibleSegments = [];
                let currentSegment = [];
                
                for (let i = 0; i < marker.trail.length; i++) {
                    const trailPoint = marker.trail[i];
                    let point = sphericalTo3D(trailPoint.lat, trailPoint.lon);
                    
                    // Make trail hover at same height as dots
                    const hoverHeight = 8;
                    const surfaceNormal = normalize(point);
                    const hoveredPoint = {
                        x: point.x + surfaceNormal.x * hoverHeight,
                        y: point.y + surfaceNormal.y * hoverHeight,
                        z: point.z + surfaceNormal.z * hoverHeight
                    };
                    
                    point = applyMatrix(hoveredPoint, rotationMatrix);
                    const projected = project(point);
                    
                    // Calculate visibility
                    const depth = (point.z / (radius + hoverHeight) + 1) / 2;
                    
                    if (depth > 0.35) {
                        currentSegment.push({ 
                            proj: projected, 
                            depth: depth, 
                            index: i 
                        });
                    } else {
                        if (currentSegment.length > 1) {
                            visibleSegments.push(currentSegment);
                        }
                        currentSegment = [];
                    }
                }
                
                if (currentSegment.length > 1) {
                    visibleSegments.push(currentSegment);
                }
                
                // Draw each visible segment as a solid worm
                visibleSegments.forEach(segment => {
                    if (segment.length < 2) return;
                    
                    // Draw the white border (larger width)
                    ctx.lineWidth = 10;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(segment[0].proj.x, segment[0].proj.y);
                    
                    for (let i = 1; i < segment.length; i++) {
                        ctx.lineTo(segment[i].proj.x, segment[i].proj.y);
                    }
                    
                    // Calculate overall opacity based on depth
                    const avgDepth = segment.reduce((sum, pt) => sum + pt.depth, 0) / segment.length;
                    let opacity;
                    if (avgDepth > 0.55) {
                        opacity = 0.9;
                    } else {
                        const fadeProgress = (avgDepth - 0.35) / 0.2;
                        opacity = 0.9 * fadeProgress;
                    }
                    
                    // White border
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.stroke();
                    
                    // Draw the colored core (smaller width)
                    ctx.lineWidth = 6;
                    
                    ctx.beginPath();
                    ctx.moveTo(segment[0].proj.x, segment[0].proj.y);
                    
                    for (let i = 1; i < segment.length; i++) {
                        ctx.lineTo(segment[i].proj.x, segment[i].proj.y);
                    }
                    
                    // Colored core
                    ctx.strokeStyle = hexToRgba(marker.color, opacity);
                    ctx.stroke();
                });
            });
            
        }
        
        // Store globe contexts for reset functionality
        const globeContexts = [];
        
        // Matrix interpolation for smooth animation
        function matrixToQuaternion(m) {
            const w = Math.sqrt(1 + m[0][0] + m[1][1] + m[2][2]) / 2;
            const w4 = 4 * w;
            const x = (m[2][1] - m[1][2]) / w4;
            const y = (m[0][2] - m[2][0]) / w4;
            const z = (m[1][0] - m[0][1]) / w4;
            return { w, x, y, z };
        }
        
        function quaternionToMatrix(q) {
            const { w, x, y, z } = q;
            return [
                [1 - 2*(y*y + z*z), 2*(x*y - w*z), 2*(x*z + w*y)],
                [2*(x*y + w*z), 1 - 2*(x*x + z*z), 2*(y*z - w*x)],
                [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x*x + y*y)]
            ];
        }
        
        function slerpQuaternion(q1, q2, t) {
            let dot = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
            
            // If dot is negative, negate one quaternion to take the shorter path
            if (dot < 0) {
                q2 = { w: -q2.w, x: -q2.x, y: -q2.y, z: -q2.z };
                dot = -dot;
            }
            
            // If quaternions are very close, use linear interpolation
            if (dot > 0.9995) {
                return {
                    w: q1.w + t * (q2.w - q1.w),
                    x: q1.x + t * (q2.x - q1.x),
                    y: q1.y + t * (q2.y - q1.y),
                    z: q1.z + t * (q2.z - q1.z)
                };
            }
            
            // Use spherical linear interpolation
            const theta = Math.acos(dot);
            const sinTheta = Math.sin(theta);
            const a = Math.sin((1 - t) * theta) / sinTheta;
            const b = Math.sin(t * theta) / sinTheta;
            
            return {
                w: a * q1.w + b * q2.w,
                x: a * q1.x + b * q2.x,
                y: a * q1.y + b * q2.y,
                z: a * q1.z + b * q2.z
            };
        }
        
        // GLOBE 1: Trackball control
        (function() {
            const canvas = document.getElementById('globe1');
            const ctx = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;
            
            let rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            let isDragging = false;
            let lastSpherePoint = null;
            let animationId = null;
            let velocity = { axis: { x: 0, y: 0, z: 0 }, angle: 0 };
            let lastTime = 0;
            const friction = 0.95;
            const minVelocity = 0.001;
            
            function screenToSphere(screenX, screenY) {
                const rect = canvas.getBoundingClientRect();
                const x = (screenX - rect.left - centerX) / radius;
                const y = (centerY - (screenY - rect.top)) / radius;
                const lengthSquared = x * x + y * y;
                
                if (lengthSquared > 1.0) {
                    const length = Math.sqrt(lengthSquared);
                    return { x: x / length, y: y / length, z: 0 };
                } else {
                    return { x, y, z: Math.sqrt(1 - lengthSquared) };
                }
            }
            

            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && lastSpherePoint) {
                    const currentTime = performance.now();
                    const currentSpherePoint = screenToSphere(e.clientX, e.clientY);
                    const axis = cross(lastSpherePoint, currentSpherePoint);
                    const axisLength = Math.sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
                    
                    if (axisLength > 0.0001) {
                        const normalizedAxis = normalize(axis);
                        const angle = Math.asin(Math.min(1, axisLength));
                        
                        // Track velocity
                        const deltaTime = Math.max(1, currentTime - lastTime);
                        velocity = {
                            axis: normalizedAxis,
                            angle: angle * 25 / deltaTime // Scale for smooth motion
                        };
                        
                        const incrementalRotation = rotationMatrixFromAxisAngle(normalizedAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        lastSpherePoint = currentSpherePoint;
                        lastTime = currentTime;
                        drawGlobe(ctx, rotationMatrix);
                    }
                }
            });
            
            function applyMomentum() {
                if (!isDragging && Math.abs(velocity.angle) > minVelocity) {
                    velocity.angle *= friction;
                    
                    if (Math.abs(velocity.angle) > minVelocity) {
                        const incrementalRotation = rotationMatrixFromAxisAngle(velocity.axis, velocity.angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        drawGlobe(ctx, rotationMatrix);
                        animationId = requestAnimationFrame(applyMomentum);
                    } else {
                        velocity.angle = 0;
                    }
                }
            }
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastSpherePoint = screenToSphere(e.clientX, e.clientY);
                lastTime = performance.now();
                velocity = { axis: { x: 0, y: 0, z: 0 }, angle: 0 };
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                lastSpherePoint = null;
                if (Math.abs(velocity.angle) > minVelocity) {
                    animationId = requestAnimationFrame(applyMomentum);
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                lastSpherePoint = null;
            });
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                lastSpherePoint = screenToSphere(e.touches[0].clientX, e.touches[0].clientY);
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && lastSpherePoint) {
                    const currentSpherePoint = screenToSphere(e.touches[0].clientX, e.touches[0].clientY);
                    const axis = cross(lastSpherePoint, currentSpherePoint);
                    const axisLength = Math.sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
                    
                    if (axisLength > 0.0001) {
                        const normalizedAxis = normalize(axis);
                        const angle = Math.asin(Math.min(1, axisLength));
                        const incrementalRotation = rotationMatrixFromAxisAngle(normalizedAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        lastSpherePoint = currentSpherePoint;
                        drawGlobe(ctx, rotationMatrix);
                    }
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
                lastSpherePoint = null;
            });
            
            // Start continuous animation for worm movement
            function animate() {
                drawGlobe(ctx, rotationMatrix);
                requestAnimationFrame(animate);
            }
            
            // Expose context for reset functionality
            globeContexts.push({
                ctx,
                getMatrix: () => rotationMatrix,
                setMatrix: (m) => { rotationMatrix = m; },
                draw: () => drawGlobe(ctx, rotationMatrix),
                cancelAnimation: () => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                },
                setAnimationId: (id) => { animationId = id; }
            });
            
            animate();
        })();
        
        // GLOBE 2: Axis Lock control
        (function() {
            const canvas = document.getElementById('globe2');
            const ctx = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;
            
            let rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;
            let dragAxis = null; // 'horizontal' or 'vertical'
            let animationId = null;
            let velocity = 0;
            let velocityAxis = null;
            let lastTime = 0;
            const friction = 0.95;
            const minVelocity = 0.001;
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                dragAxis = null;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const currentTime = performance.now();
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    
                    // Determine drag direction on first significant movement
                    if (!dragAxis) {
                        if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                            dragAxis = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                        }
                    }
                    
                    if (dragAxis === 'horizontal') {
                        // Rotate around Y axis (vertical axis)
                        const angle = deltaX * 0.01;
                        const yAxis = { x: 0, y: 1, z: 0 };
                        
                        // Track velocity
                        const deltaTime = Math.max(1, currentTime - lastTime);
                        velocity = angle * 25 / deltaTime;
                        velocityAxis = yAxis;
                        
                        const incrementalRotation = rotationMatrixFromAxisAngle(yAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    } else if (dragAxis === 'vertical') {
                        // Rotate around X axis (horizontal axis)
                        const angle = deltaY * 0.01;
                        const xAxis = { x: 1, y: 0, z: 0 };
                        
                        // Track velocity
                        const deltaTime = Math.max(1, currentTime - lastTime);
                        velocity = angle * 25 / deltaTime;
                        velocityAxis = xAxis;
                        
                        const incrementalRotation = rotationMatrixFromAxisAngle(xAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    }
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                    lastTime = currentTime;
                    drawGlobe(ctx, rotationMatrix);
                }
            });
            
            function applyMomentum() {
                if (!isDragging && Math.abs(velocity) > minVelocity && velocityAxis) {
                    velocity *= friction;
                    
                    if (Math.abs(velocity) > minVelocity) {
                        const incrementalRotation = rotationMatrixFromAxisAngle(velocityAxis, velocity);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                        drawGlobe(ctx, rotationMatrix);
                        animationId = requestAnimationFrame(applyMomentum);
                    } else {
                        velocity = 0;
                    }
                }
            }
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                lastTime = performance.now();
                dragAxis = null;
                velocity = 0;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragAxis = null;
                if (Math.abs(velocity) > minVelocity) {
                    animationId = requestAnimationFrame(applyMomentum);
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                dragAxis = null;
            });
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                dragAxis = null;
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;
                    
                    if (!dragAxis) {
                        if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                            dragAxis = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                        }
                    }
                    
                    if (dragAxis === 'horizontal') {
                        const angle = -deltaX * 0.01;
                        const yAxis = { x: 0, y: 1, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(yAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    } else if (dragAxis === 'vertical') {
                        const angle = -deltaY * 0.01;
                        const xAxis = { x: 1, y: 0, z: 0 };
                        const incrementalRotation = rotationMatrixFromAxisAngle(xAxis, angle);
                        rotationMatrix = multiplyMatrices(incrementalRotation, rotationMatrix);
                    }
                    
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    drawGlobe(ctx, rotationMatrix);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
                dragAxis = null;
            });
            
            // Start continuous animation for worm movement
            function animate() {
                drawGlobe(ctx, rotationMatrix);
                requestAnimationFrame(animate);
            }
            
            // Expose context for reset functionality
            globeContexts.push({
                ctx,
                getMatrix: () => rotationMatrix,
                setMatrix: (m) => { rotationMatrix = m; },
                draw: () => drawGlobe(ctx, rotationMatrix),
                cancelAnimation: () => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                },
                setAnimationId: (id) => { animationId = id; }
            });
            
            animate();
        })();
        
        // Reset button functionality
        document.getElementById('resetButton').addEventListener('click', () => {
            // Cancel any existing animations
            globeContexts.forEach(globe => globe.cancelAnimation());
            
            const identityMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            const identityQuat = { w: 1, x: 0, y: 0, z: 0 };
            const duration = 1000; // 1 second animation
            const startTime = performance.now();
            
            // Get starting quaternions for both globes
            const startQuats = globeContexts.map(globe => 
                matrixToQuaternion(globe.getMatrix())
            );
            
            // Calculate the maximum rotation angle to normalize speed
            const rotationAmounts = startQuats.map(q => {
                const dot = Math.min(1, Math.abs(q.w)); // Clamp to avoid numerical issues
                return Math.acos(dot) * 2; // Total rotation angle
            });
            const maxRotation = Math.max(...rotationAmounts);
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const rawProgress = Math.min(elapsed / duration, 1);
                
                // Use ease-in-out cubic for smooth animation
                const t = rawProgress < 0.5
                    ? 4 * rawProgress * rawProgress * rawProgress
                    : 1 - Math.pow(-2 * rawProgress + 2, 3) / 2;
                
                if (t < 1) {
                    globeContexts.forEach((globe, index) => {
                        // Adjust progress based on rotation amount to sync finish times
                        const adjustedT = maxRotation > 0.01 
                            ? Math.min(1, t * (maxRotation / Math.max(0.01, rotationAmounts[index])))
                            : t;
                        
                        const interpolatedQuat = slerpQuaternion(startQuats[index], identityQuat, adjustedT);
                        const interpolatedMatrix = quaternionToMatrix(interpolatedQuat);
                        globe.setMatrix(interpolatedMatrix);
                        globe.draw();
                    });
                    
                    const animId = requestAnimationFrame(animate);
                    globeContexts.forEach(globe => globe.setAnimationId(animId));
                } else {
                    // Ensure we end at exactly the identity matrix
                    globeContexts.forEach(globe => {
                        globe.setMatrix(identityMatrix);
                        globe.draw();
                        globe.setAnimationId(null);
                    });
                }
            }
            
            animate(startTime);
        });
    </script>
</body>
</html>