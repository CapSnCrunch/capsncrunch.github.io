<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe Worm Picker Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .container {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .globe-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        canvas {
            cursor: grab;
            border-radius: 50%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }
        canvas:active {
            cursor: grabbing;
        }
        .label {
            text-align: center;
            max-width: 300px;
        }
        .label h3 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
        }
        .label p {
            margin: 0;
            color: #666;
            font-size: 14px;
            line-height: 1.4;
        }
        .reset-button {
            background: white;
            border: 2px solid #d0d0d0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-top: calc(50% - 60px);
        }
        .reset-button:hover {
            background: #f8f8f8;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }
        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .reset-button svg {
            width: 24px;
            height: 24px;
            stroke: #666;
            stroke-width: 2;
            fill: none;
            transition: transform 0.3s ease;
        }
        .reset-button:hover svg {
            transform: rotate(-45deg);
        }
        
        /* Score display */
        .score-container {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 30px;
            border-radius: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            z-index: 100;
        }
        .score-label {
            color: #666;
            font-weight: 400;
        }
        .score-value {
            color: #4CAF50;
            font-size: 24px;
            min-width: 30px;
            text-align: center;
        }
        .worm-icon {
            width: 30px;
            height: 30px;
            position: relative;
        }
        .worm-icon::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 4px;
            transform: translateY(-50%);
        }
        
        /* Click feedback animation */
        @keyframes pickupPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        .pickup-effect {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #4CAF50;
            pointer-events: none;
            animation: pickupPulse 0.5s ease-out;
            z-index: 1000;
        }
        
        /* Dangling worm canvas */
        #danglingWormCanvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <!-- Score display -->
    <div class="score-container">
        <div class="worm-icon"></div>
        <span class="score-label">Worms Collected:</span>
        <span class="score-value" id="score">0</span>
    </div>
    
    <!-- Canvas for dangling worm effect -->
    <canvas id="danglingWormCanvas"></canvas>
    
    <div class="container">
        <div class="globe-wrapper">
            <canvas id="globe1"></canvas>
            <div class="label">
                <h3>Trackball</h3>
                <p>Middle-click to rotate • Left-click worms to collect them</p>
            </div>
        </div>
        
        <button class="reset-button" id="resetButton" title="Reset globes">
            <svg viewBox="0 0 24 24">
                <path d="M12 4a8 8 0 1 1-3.5 15.2" />
                <polyline points="12 4 12 8 8 8" />
            </svg>
        </button>
        
        <div class="globe-wrapper">
            <canvas id="globe2"></canvas>
            <div class="label">
                <h3>Axis Lock</h3>
                <p>Middle-click to rotate • Left-click worms to collect them</p>
            </div>
        </div>
    </div>
    
    <script>
        // Global settings
        const size = Math.min(window.innerWidth * 0.45, window.innerHeight * 0.65, 500);
        const centerX = size / 2;
        const centerY = size / 2;
        const radius = size * 0.42;
        
        // Game state
        let wormsCollected = 0;
        let danglingWorm = null;
        let fallingWorm = null;
        let mousePos = { x: 0, y: 0 };
        let prevMousePos = { x: 0, y: 0 };
        let mouseVelocity = { x: 0, y: 0 };
        let currentHoverCanvas = null;
        let currentHoverMatrix = null;
        
        // Worm physics
        let wormSegments = [];
        const SEGMENT_COUNT = 15;
        const SEGMENT_LENGTH = 10;
        const DAMPING = 0.92;
        const GRAVITY = 0.4;
        const MOUSE_INFLUENCE = 0.3;
        
        // Canvas setup
        const danglingCanvas = document.getElementById('danglingWormCanvas');
        const danglingCtx = danglingCanvas.getContext('2d');
        danglingCanvas.width = window.innerWidth;
        danglingCanvas.height = window.innerHeight;
        
        // Worm data
        const markers = [
            { lat: 0, lon: 0, color: '#ff4444', speed: 0.01, path: 'lon', trail: [], id: 'worm1' },
            { lat: Math.PI/4, lon: Math.PI/4, color: '#44ff44', speed: 0.012, path: 'lat', trail: [], id: 'worm2' },
            { lat: -Math.PI/4, lon: Math.PI/2, color: '#4444ff', speed: 0.008, path: 'lon', trail: [], id: 'worm3' },
            { lat: Math.PI/3, lon: -Math.PI/3, color: '#ff44ff', speed: 0.015, path: 'lat', trail: [], id: 'worm4' },
            { lat: -Math.PI/6, lon: Math.PI, color: '#ffaa44', speed: 0.011, path: 'lon', trail: [], id: 'worm5' },
            { lat: Math.PI/6, lon: -Math.PI/2, color: '#44ffff', speed: 0.009, path: 'lat', trail: [], id: 'worm6' },
        ];
        
        const maxTrailLength = 50;
        let animationTime = 0;
        let wormIdCounter = 7;
        
        // Globe contexts storage
        const globeContexts = [];
        
        // Utility functions
        const sphericalTo3D = (lat, lon) => ({
            x: radius * Math.cos(lat) * Math.cos(lon),
            y: radius * Math.sin(lat),
            z: radius * Math.cos(lat) * Math.sin(lon)
        });
        
        const applyMatrix = (point, matrix) => ({
            x: matrix[0][0] * point.x + matrix[0][1] * point.y + matrix[0][2] * point.z,
            y: matrix[1][0] * point.x + matrix[1][1] * point.y + matrix[1][2] * point.z,
            z: matrix[2][0] * point.x + matrix[2][1] * point.y + matrix[2][2] * point.z
        });
        
        const multiplyMatrices = (a, b) => {
            const result = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                    for (let k = 0; k < 3; k++)
                        result[i][j] += a[i][k] * b[k][j];
            return result;
        };
        
        const rotationMatrixFromAxisAngle = (axis, angle) => {
            const c = Math.cos(angle), s = Math.sin(angle), t = 1 - c;
            const {x, y, z} = axis;
            return [
                [t*x*x + c,   t*x*y - s*z, t*x*z + s*y],
                [t*x*y + s*z, t*y*y + c,   t*y*z - s*x],
                [t*x*z - s*y, t*y*z + s*x, t*z*z + c  ]
            ];
        };
        
        const cross = (a, b) => ({
            x: a.y * b.z - a.z * b.y,
            y: a.z * b.x - a.x * b.z,
            z: a.x * b.y - a.y * b.x
        });
        
        const normalize = v => {
            const len = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return len < 0.0001 ? { x: 0, y: 0, z: 1 } : { x: v.x/len, y: v.y/len, z: v.z/len };
        };
        
        const project = point3D => ({
            x: centerX + point3D.x,
            y: centerY - point3D.y,
            z: point3D.z
        });
        
        const hexToRgba = (hex, alpha) => {
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };
        
        const hexToRgb = hex => ({
            r: parseInt(hex.slice(1,3), 16),
            g: parseInt(hex.slice(3,5), 16),
            b: parseInt(hex.slice(5,7), 16)
        });
        
        const randomColor = () => {
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ff44ff', '#ffaa44', '#44ffff', '#ff8844', '#8844ff'];
            return colors[Math.floor(Math.random() * colors.length)];
        };
        
        // Mouse tracking
        document.addEventListener('mousemove', e => {
            prevMousePos = {...mousePos};
            mousePos = { x: e.clientX, y: e.clientY };
            mouseVelocity = { x: mousePos.x - prevMousePos.x, y: mousePos.y - prevMousePos.y };
            
            // Track which canvas we're hovering over
            const globe1 = document.getElementById('globe1').getBoundingClientRect();
            const globe2 = document.getElementById('globe2').getBoundingClientRect();
            
            if (e.clientX >= globe1.left && e.clientX <= globe1.right && 
                e.clientY >= globe1.top && e.clientY <= globe1.bottom) {
                currentHoverCanvas = 0;
                currentHoverMatrix = globeContexts[0]?.getMatrix();
            } else if (e.clientX >= globe2.left && e.clientX <= globe2.right && 
                       e.clientY >= globe2.top && e.clientY <= globe2.bottom) {
                currentHoverCanvas = 1;
                currentHoverMatrix = globeContexts[1]?.getMatrix();
            } else {
                currentHoverCanvas = null;
                currentHoverMatrix = null;
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', e => {
            if (e.key === 'q' && currentHoverCanvas !== null && currentHoverMatrix) {
                // Convert mouse position to sphere coordinates
                const canvas = currentHoverCanvas === 0 ? document.getElementById('globe1') : document.getElementById('globe2');
                const rect = canvas.getBoundingClientRect();
                const localX = mousePos.x - rect.left - centerX;
                const localY = centerY - (mousePos.y - rect.top);
                
                // Simple inverse projection to get approximate sphere position
                const dist = Math.sqrt(localX * localX + localY * localY);
                if (dist <= radius) {
                    // Random starting position near cursor
                    const lat = (Math.random() - 0.5) * Math.PI * 0.8;
                    const lon = (Math.random() - 0.5) * Math.PI * 2;
                    
                    const newWorm = {
                        lat,
                        lon,
                        color: randomColor(),
                        speed: 0.005 + Math.random() * 0.015,
                        path: Math.random() > 0.5 ? 'lon' : 'lat',
                        trail: [],
                        id: `worm${wormIdCounter++}`
                    };
                    
                    markers.push(newWorm);
                }
            }
        });
        
        // Worm physics functions
        const initializeWormPhysics = (x, y) => {
            wormSegments = [];
            for (let i = 0; i < SEGMENT_COUNT; i++) {
                wormSegments.push({
                    x, y: y + i * SEGMENT_LENGTH,
                    vx: 0, vy: 0,
                    oldX: x, oldY: y + i * SEGMENT_LENGTH
                });
            }
        };
        
        const updateWormPhysics = () => {
            if (!danglingWorm) return;
            
            const seg0 = wormSegments[0];
            seg0.oldX = seg0.x;
            seg0.oldY = seg0.y;
            seg0.vx += (mousePos.x - seg0.x) * MOUSE_INFLUENCE + mouseVelocity.x * 0.5;
            seg0.vy += (mousePos.y - seg0.y) * MOUSE_INFLUENCE + mouseVelocity.y * 0.5;
            seg0.vx *= DAMPING;
            seg0.vy *= DAMPING;
            seg0.x += seg0.vx;
            seg0.y += seg0.vy;
            
            for (let i = 1; i < wormSegments.length; i++) {
                const prev = wormSegments[i - 1];
                const curr = wormSegments[i];
                
                curr.oldX = curr.x;
                curr.oldY = curr.y;
                
                const dx = prev.x - curr.x;
                const dy = prev.y - curr.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const diff = (SEGMENT_LENGTH - dist) / dist;
                    curr.x -= dx * diff * 0.5;
                    curr.y -= dy * diff * 0.5;
                }
                
                curr.vy += GRAVITY;
                curr.vx = (curr.x - curr.oldX) * 0.9;
                curr.vy = (curr.y - curr.oldY) * 0.9;
                curr.vx *= DAMPING;
                curr.vy *= DAMPING;
                curr.x += curr.vx;
                curr.y += curr.vy;
            }
        };
        
        const updateFallingWorm = () => {
            if (!fallingWorm) return;
            
            fallingWorm.opacity = Math.max(0, fallingWorm.opacity - 0.01);
            
            for (let i = 0; i < fallingWorm.segments.length; i++) {
                const seg = fallingWorm.segments[i];
                seg.vy += GRAVITY * 1.5;
                seg.vx += (Math.random() - 0.5) * 0.2;
                seg.vx *= 0.98;
                seg.x += seg.vx;
                seg.y += seg.vy;
                
                if (i > 0) {
                    const prev = fallingWorm.segments[i - 1];
                    const dx = prev.x - seg.x;
                    const dy = prev.y - seg.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > SEGMENT_LENGTH * 1.5) {
                        const diff = (SEGMENT_LENGTH * 1.5 - dist) / dist;
                        seg.x -= dx * diff * 0.2;
                        seg.y -= dy * diff * 0.2;
                    }
                }
            }
        };
        
        const drawWormSegments = (segments, color, opacity) => {
            if (segments.length < 2) return;
            
            const paths = [[2, 2, 0.2, 12], [0, 0, 1, 10]];
            paths.forEach(([ox, oy, op, w]) => {
                danglingCtx.strokeStyle = ox ? `rgba(0, 0, 0, ${op * opacity})` : `rgba(255, 255, 255, ${opacity})`;
                danglingCtx.lineWidth = w;
                danglingCtx.lineCap = 'round';
                danglingCtx.lineJoin = 'round';
                danglingCtx.beginPath();
                danglingCtx.moveTo(segments[0].x + ox, segments[0].y + oy);
                segments.slice(1).forEach(s => danglingCtx.lineTo(s.x + ox, s.y + oy));
                danglingCtx.stroke();
            });
            
            const gradient = danglingCtx.createLinearGradient(
                segments[0].x, segments[0].y,
                segments[segments.length - 1].x, segments[segments.length - 1].y
            );
            const rgb = hexToRgb(color);
            gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`);
            gradient.addColorStop(1, `rgba(${rgb.r * 0.7}, ${rgb.g * 0.7}, ${rgb.b * 0.7}, ${opacity})`);
            
            danglingCtx.strokeStyle = gradient;
            danglingCtx.lineWidth = 6;
            danglingCtx.beginPath();
            danglingCtx.moveTo(segments[0].x, segments[0].y);
            segments.slice(1).forEach(s => danglingCtx.lineTo(s.x, s.y));
            danglingCtx.stroke();
        };
        
        const drawDanglingWorm = () => {
            danglingCtx.clearRect(0, 0, danglingCanvas.width, danglingCanvas.height);
            
            if (fallingWorm) {
                updateFallingWorm();
                drawWormSegments(fallingWorm.segments, fallingWorm.color, fallingWorm.opacity);
                
                const lastSeg = fallingWorm.segments[fallingWorm.segments.length - 1];
                if (lastSeg.y > window.innerHeight + 100) {
                    fallingWorm = null;
                    wormsCollected++;
                    document.getElementById('score').textContent = wormsCollected;
                }
            }
            
            if (danglingWorm) {
                updateWormPhysics();
                drawWormSegments(wormSegments, danglingWorm.color, 1);
            }
            
            if (danglingWorm || fallingWorm) requestAnimationFrame(drawDanglingWorm);
        };
        
        const pointToSegmentDistance = (px, py, x1, y1, x2, y2) => {
            const dx = x2 - x1, dy = y2 - y1;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lenSq));
            const projX = x1 + t * dx, projY = y1 + t * dy;
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        };
        
        const checkWormGrab = (clickX, clickY, rotationMatrix, canvasRect) => {
            const localX = clickX - canvasRect.left;
            const localY = clickY - canvasRect.top;
            
            for (let i = markers.length - 1; i >= 0; i--) {
                const marker = markers[i];
                if (marker.trail.length < 2) continue;
                
                for (let j = 0; j < marker.trail.length - 1; j++) {
                    let p1 = sphericalTo3D(marker.trail[j].lat, marker.trail[j].lon);
                    let p2 = sphericalTo3D(marker.trail[j + 1].lat, marker.trail[j + 1].lon);
                    
                    const n1 = normalize(p1), n2 = normalize(p2);
                    p1 = {x: p1.x + n1.x * 8, y: p1.y + n1.y * 8, z: p1.z + n1.z * 8};
                    p2 = {x: p2.x + n2.x * 8, y: p2.y + n2.y * 8, z: p2.z + n2.z * 8};
                    
                    p1 = applyMatrix(p1, rotationMatrix);
                    p2 = applyMatrix(p2, rotationMatrix);
                    
                    const d1 = (p1.z / (radius + 8) + 1) / 2;
                    const d2 = (p2.z / (radius + 8) + 1) / 2;
                    
                    if (d1 > 0.35 && d2 > 0.35) {
                        const proj1 = project(p1), proj2 = project(p2);
                        
                        if (pointToSegmentDistance(localX, localY, proj1.x, proj1.y, proj2.x, proj2.y) <= 25) {
                            danglingWorm = {color: marker.color, id: marker.id};
                            markers.splice(i, 1);
                            initializeWormPhysics(clickX, clickY);
                            drawDanglingWorm();
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        
        document.addEventListener('mouseup', e => {
            if (e.button === 0 && danglingWorm) {
                fallingWorm = {
                    segments: wormSegments.map(seg => ({
                        x: seg.x, y: seg.y,
                        vx: seg.vx * 2, vy: seg.vy + 2
                    })),
                    color: danglingWorm.color,
                    opacity: 1
                };
                danglingWorm = null;
                wormSegments = [];
                if (!danglingWorm) drawDanglingWorm();
            }
        });
        
        const updateMarkers = () => {
            animationTime += 0.016;
            markers.forEach(marker => {
                if (marker.path === 'lon') {
                    marker.lon += marker.speed;
                    if (marker.lon > Math.PI) marker.lon -= 2 * Math.PI;
                    if (marker.lon < -Math.PI) marker.lon += 2 * Math.PI;
                } else {
                    marker.lat += marker.speed;
                    if (marker.lat > Math.PI/2.2) {
                        marker.lat = Math.PI/2.2;
                        marker.speed = -marker.speed;
                    }
                    if (marker.lat < -Math.PI/2.2) {
                        marker.lat = -Math.PI/2.2;
                        marker.speed = -marker.speed;
                    }
                }
                marker.trail.push({lat: marker.lat, lon: marker.lon});
                if (marker.trail.length > maxTrailLength) marker.trail.shift();
            });
        };
        
        const drawGlobe = (ctx, rotationMatrix) => {
            updateMarkers();
            ctx.clearRect(0, 0, size, size);
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let lat = -Math.PI/3; lat <= Math.PI/3; lat += Math.PI/12) {
                ctx.beginPath();
                let first = true;
                for (let lon = -Math.PI; lon <= Math.PI; lon += Math.PI/36) {
                    const p = project(applyMatrix(sphericalTo3D(lat, lon), rotationMatrix));
                    if (p.z >= 0) {
                        if (first) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                        first = false;
                    } else first = true;
                }
                ctx.stroke();
            }
            
            for (let lon = 0; lon < Math.PI * 2; lon += Math.PI/8) {
                ctx.beginPath();
                let first = true;
                for (let lat = -Math.PI/2; lat <= Math.PI/2; lat += Math.PI/36) {
                    const p = project(applyMatrix(sphericalTo3D(lat, lon), rotationMatrix));
                    if (p.z >= 0) {
                        if (first) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                        first = false;
                    } else first = true;
                }
                ctx.stroke();
            }
            
            // Draw worms
            markers.forEach(marker => {
                if (marker.trail.length < 2) return;
                const segments = [];
                let currentSeg = [];
                
                marker.trail.forEach(tp => {
                    let p = sphericalTo3D(tp.lat, tp.lon);
                    const n = normalize(p);
                    p = {x: p.x + n.x * 8, y: p.y + n.y * 8, z: p.z + n.z * 8};
                    p = applyMatrix(p, rotationMatrix);
                    const proj = project(p);
                    const depth = (p.z / (radius + 8) + 1) / 2;
                    
                    if (depth > 0.35) currentSeg.push({proj, depth});
                    else {
                        if (currentSeg.length > 1) segments.push(currentSeg);
                        currentSeg = [];
                    }
                });
                if (currentSeg.length > 1) segments.push(currentSeg);
                
                segments.forEach(seg => {
                    if (seg.length < 2) return;
                    const avgDepth = seg.reduce((s, p) => s + p.depth, 0) / seg.length;
                    const opacity = avgDepth > 0.55 ? 0.9 : 0.9 * ((avgDepth - 0.35) / 0.2);
                    
                    [10, 6].forEach((w, i) => {
                        ctx.lineWidth = w;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.strokeStyle = i ? hexToRgba(marker.color, opacity) : `rgba(255, 255, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(seg[0].proj.x, seg[0].proj.y);
                        seg.slice(1).forEach(s => ctx.lineTo(s.proj.x, s.proj.y));
                        ctx.stroke();
                    });
                });
            });
        };
        
        const matrixToQuaternion = m => {
            const w = Math.sqrt(1 + m[0][0] + m[1][1] + m[2][2]) / 2;
            return {
                w, x: (m[2][1] - m[1][2]) / (4*w),
                y: (m[0][2] - m[2][0]) / (4*w),
                z: (m[1][0] - m[0][1]) / (4*w)
            };
        };
        
        const quaternionToMatrix = ({w, x, y, z}) => [
            [1 - 2*(y*y + z*z), 2*(x*y - w*z), 2*(x*z + w*y)],
            [2*(x*y + w*z), 1 - 2*(x*x + z*z), 2*(y*z - w*x)],
            [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x*x + y*y)]
        ];
        
        const slerpQuaternion = (q1, q2, t) => {
            let dot = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
            if (dot < 0) {
                q2 = {w: -q2.w, x: -q2.x, y: -q2.y, z: -q2.z};
                dot = -dot;
            }
            if (dot > 0.9995) return {
                w: q1.w + t * (q2.w - q1.w), x: q1.x + t * (q2.x - q1.x),
                y: q1.y + t * (q2.y - q1.y), z: q1.z + t * (q2.z - q1.z)
            };
            const theta = Math.acos(dot), sinTheta = Math.sin(theta);
            const a = Math.sin((1 - t) * theta) / sinTheta;
            const b = Math.sin(t * theta) / sinTheta;
            return {
                w: a * q1.w + b * q2.w, x: a * q1.x + b * q2.x,
                y: a * q1.y + b * q2.y, z: a * q1.z + b * q2.z
            };
        };
        
        // Initialize globes
        ['globe1', 'globe2'].forEach((id, idx) => {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.height = size;
            
            let rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
            let isDragging = false;
            let animationId = null;
            
            if (idx === 0) {
                // Trackball control
                let lastSpherePoint = null;
                let velocity = {axis: {x: 0, y: 0, z: 0}, angle: 0};
                let lastTime = 0;
                
                const screenToSphere = (sx, sy) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = (sx - rect.left - centerX) / radius;
                    const y = (centerY - (sy - rect.top)) / radius;
                    const lenSq = x * x + y * y;
                    if (lenSq > 1) {
                        const len = Math.sqrt(lenSq);
                        return {x: x/len, y: y/len, z: 0};
                    }
                    return {x, y, z: Math.sqrt(1 - lenSq)};
                };
                
                canvas.addEventListener('mousemove', e => {
                    if (isDragging && lastSpherePoint) {
                        const cur = screenToSphere(e.clientX, e.clientY);
                        const axis = cross(lastSpherePoint, cur);
                        const axisLen = Math.sqrt(axis.x**2 + axis.y**2 + axis.z**2);
                        
                        if (axisLen > 0.0001) {
                            const norm = normalize(axis);
                            const angle = Math.asin(Math.min(1, axisLen));
                            const dt = Math.max(1, performance.now() - lastTime);
                            velocity = {axis: norm, angle: angle * 25 / dt};
                            rotationMatrix = multiplyMatrices(rotationMatrixFromAxisAngle(norm, angle), rotationMatrix);
                            lastSpherePoint = cur;
                            lastTime = performance.now();
                        }
                    }
                });
                
                canvas.addEventListener('mousedown', e => {
                    if (e.button === 0 && !danglingWorm) {
                        checkWormGrab(e.clientX, e.clientY, rotationMatrix, canvas.getBoundingClientRect());
                    } else if (e.button === 1) {
                        isDragging = true;
                        lastSpherePoint = screenToSphere(e.clientX, e.clientY);
                        lastTime = performance.now();
                        velocity = {axis: {x: 0, y: 0, z: 0}, angle: 0};
                        if (animationId) cancelAnimationFrame(animationId);
                        e.preventDefault();
                    }
                });
                
                canvas.addEventListener('mouseup', e => {
                    if (e.button === 1) {
                        isDragging = false;
                        lastSpherePoint = null;
                        if (Math.abs(velocity.angle) > 0.001) {
                            const applyMomentum = () => {
                                if (!isDragging && Math.abs(velocity.angle) > 0.001) {
                                    velocity.angle *= 0.95;
                                    rotationMatrix = multiplyMatrices(rotationMatrixFromAxisAngle(velocity.axis, velocity.angle), rotationMatrix);
                                    drawGlobe(ctx, rotationMatrix);
                                    if (Math.abs(velocity.angle) > 0.001) animationId = requestAnimationFrame(applyMomentum);
                                }
                            };
                            animationId = requestAnimationFrame(applyMomentum);
                        }
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                    lastSpherePoint = null;
                });
            } else {
                // Axis lock control
                let lastX = 0, lastY = 0, dragAxis = null;
                let velocity = 0, velocityAxis = null;
                
                canvas.addEventListener('mousemove', e => {
                    if (isDragging) {
                        const dx = e.clientX - lastX, dy = e.clientY - lastY;
                        if (!dragAxis && (Math.abs(dx) > 2 || Math.abs(dy) > 2)) {
                            dragAxis = Math.abs(dx) > Math.abs(dy) ? 'h' : 'v';
                        }
                        
                        if (dragAxis === 'h') {
                            const angle = dx * 0.01;
                            velocityAxis = {x: 0, y: 1, z: 0};
                            velocity = angle * 25 / Math.max(1, performance.now() - lastTime);
                            rotationMatrix = multiplyMatrices(rotationMatrixFromAxisAngle(velocityAxis, angle), rotationMatrix);
                        } else if (dragAxis === 'v') {
                            const angle = dy * 0.01;
                            velocityAxis = {x: 1, y: 0, z: 0};
                            velocity = angle * 25 / Math.max(1, performance.now() - lastTime);
                            rotationMatrix = multiplyMatrices(rotationMatrixFromAxisAngle(velocityAxis, angle), rotationMatrix);
                        }
                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });
                
                canvas.addEventListener('mousedown', e => {
                    if (e.button === 0 && !danglingWorm) {
                        checkWormGrab(e.clientX, e.clientY, rotationMatrix, canvas.getBoundingClientRect());
                    } else if (e.button === 1) {
                        isDragging = true;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        dragAxis = null;
                        velocity = 0;
                        if (animationId) cancelAnimationFrame(animationId);
                        e.preventDefault();
                    }
                });
                
                canvas.addEventListener('mouseup', e => {
                    if (e.button === 1) {
                        isDragging = false;
                        dragAxis = null;
                        if (Math.abs(velocity) > 0.001 && velocityAxis) {
                            const applyMomentum = () => {
                                if (!isDragging && Math.abs(velocity) > 0.001) {
                                    velocity *= 0.95;
                                    rotationMatrix = multiplyMatrices(rotationMatrixFromAxisAngle(velocityAxis, velocity), rotationMatrix);
                                    drawGlobe(ctx, rotationMatrix);
                                    if (Math.abs(velocity) > 0.001) animationId = requestAnimationFrame(applyMomentum);
                                }
                            };
                            animationId = requestAnimationFrame(applyMomentum);
                        }
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                    dragAxis = null;
                });
            }
            
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            const animate = () => {
                drawGlobe(ctx, rotationMatrix);
                requestAnimationFrame(animate);
            };
            
            globeContexts.push({
                ctx,
                getMatrix: () => rotationMatrix,
                setMatrix: m => rotationMatrix = m,
                draw: () => drawGlobe(ctx, rotationMatrix),
                cancelAnimation: () => animationId && cancelAnimationFrame(animationId),
                setAnimationId: id => animationId = id
            });
            
            animate();
        });
        
        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            globeContexts.forEach(g => g.cancelAnimation());
            const identity = [[1,0,0],[0,1,0],[0,0,1]];
            const targetQ = {w: 1, x: 0, y: 0, z: 0};
            const start = performance.now();
            const startQuats = globeContexts.map(g => matrixToQuaternion(g.getMatrix()));
            
            const animate = now => {
                const t = Math.min((now - start) / 1000, 1);
                const eased = t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
                
                if (t < 1) {
                    globeContexts.forEach((g, i) => {
                        g.setMatrix(quaternionToMatrix(slerpQuaternion(startQuats[i], targetQ, eased)));
                        g.draw();
                    });
                    const id = requestAnimationFrame(animate);
                    globeContexts.forEach(g => g.setAnimationId(id));
                } else {
                    globeContexts.forEach(g => {
                        g.setMatrix(identity);
                        g.draw();
                        g.setAnimationId(null);
                    });
                }
            };
            animate(start);
        });
    </script>
</body>
</html>